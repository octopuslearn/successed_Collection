
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html



#include <Arduino.h>
/*******************以下，编码电机引脚定义*******************/
#define AIN1 22
#define AIN2 23
#define PWMA_LEFT  4//NC
#define ENCODER_LEFT_A_1_PIN 2 //编码器
#define ENCODER_LEFT_B_1_PIN 3 //编码器
/*******************以上，编码电机引脚定义*******************/


 volatile int now_encoder=0; //当前编码器数值

float pwr;//pwm输出==

long prevT = 0;
int posPrev = 0;
// Use the "volatile" directive for variables
// used in an interrupt
volatile int pos_i = 0;
volatile float velocity_i = 0;
volatile long prevT_i = 0;

float v1Filt = 0;
float v1Prev = 0;
float v2Filt = 0;
float v2Prev = 0;

float eintegral = 0;

/*以下，声明电机，运动相关*/
void initMotors();/*初始化电机*/
void pwmOut(int dir,int pwr);/*pwm输出*/
void forwardA(int pwm);/*前进*/
void reverseA(int pwm);/*后退*/
void brakeA();/*停车*/
/*以上，声明电机，运动相关*/

/*以下，声明-编码器*/
void initEncoders();/*初始化编码器*/
void ISR_Encoder_LEFT_A_1_PIN();/*读取编码器脉冲*/
/*以上，声明-编码器*/


void setup() {
  Serial.begin(9600);
  initMotors();/*初始化电机*/
  initEncoders();/*初始化编码器*/
/*此为干扰项，打开编码器读不到正常值，只能读到0或-1*/  // FlexiTimer2_int_speed();/*PID-速度-定时器初始化*/
  Serial.println("target pos");
}

/***********以下，编码器相关**********/
/*初始化编码器*/
void initEncoders()
{
  pinMode(ENCODER_LEFT_A_1_PIN,INPUT);
  pinMode(ENCODER_LEFT_B_1_PIN,INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT_A_1_PIN), ISR_Encoder_LEFT_A_1_PIN, RISING);
}

/*读取编码器脉冲*/
void ISR_Encoder_LEFT_A_1_PIN()
{
  int increment = 0;
  if(digitalRead(ENCODER_LEFT_B_1_PIN)==HIGH)
    increment = 1;// If B is high, increment forward//如果 B 为高，则向前递增
  else
    increment = -1;// Otherwise, increment backward//否则，向后递增
  
  now_encoder += increment;

  //Compute velocity with method 2//用方法2计算速度
  long currT = micros();
  float deltaT = ((float) (currT - prevT_i))/1.0e6;
  velocity_i = increment/deltaT;
  prevT_i = currT;

  // // if(digitalRead(ENCODER_LEFT_A_1_PIN)==HIGH)
  // // {
  // //   if(digitalRead(ENCODER_LEFT_B_1_PIN)==LOW)
  // //     now_encoder++;
  // //   else
  // //     now_encoder--;
  // // }
  // // else 
  // // {
  // //   if(digitalRead(ENCODER_LEFT_B_1_PIN)==HIGH)
  // //     now_encoder++;
  // //   else
  // //     now_encoder--;
  // // }
}
/***********以上，编码器相关**********/

void loop() {

  // read the position and velocity//读取位置和速度
  int pos = 0;
  float velocity2 = 0;
  noInterrupts(); // disable interrupts temporarily while reading
  pos = now_encoder;
  velocity2 = velocity_i;
  interrupts(); // turn interrupts back on

  // Compute velocity with method 1//用方法1计算速度
  long currT = micros();
  float deltaT = ((float) (currT-prevT))/1.0e6;
  float velocity1 = (pos - posPrev)/deltaT;
  posPrev = pos;
  prevT = currT;

  // Convert count/s to RPM//将计数/秒转换为 RPM
  float v1 = velocity1/506.0*60.0;
  float v2 = velocity2/506.0*60.0;

  // Low-pass filter (25 Hz cutoff)//低通滤波器（25 Hz 截止）
  v1Filt = 0.854*v1Filt + 0.0728*v1 + 0.0728*v1Prev;
  v1Prev = v1;
  v2Filt = 0.854*v2Filt + 0.0728*v2 + 0.0728*v2Prev;
  v2Prev = v2;

// Set a target//设置目标
  float vt = 100*(sin(currT/1e6)>0);

  // Compute the control signal u
  float kp = 6;
  float ki = 10;
  float e = vt-v1Filt;
  eintegral = eintegral + e*deltaT;
  
  float u = kp*e + ki*eintegral;

  //Set the motor speed and direction
  int dir = 1;
  if (u<0){
    dir = -1;
  }
  int pwr = (int) fabs(u);
  if(pwr > 255){
    pwr = 255;
  }
  // setMotor(dir,pwr,PWM,IN1,IN2);
  pwmOut(dir,pwr);

  Serial.print(vt);
  Serial.print(" ");
  Serial.print(v1Filt);
  Serial.println();
  delay(1);
}


/**********以下，声明电机，运动相关**********/
/*初始化电机*/
void initMotors(){
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(PWMA_LEFT, OUTPUT);
  // pinMode(IN1, OUTPUT);
  // pinMode(IN2, OUTPUT);
  // pinMode(PWM, OUTPUT);
}


/*pwm输出*/
void pwmOut(int dir,int pwr)
{
  if(dir<0)//原因是此处电机方向不对
  {
    forwardA(pwr);
  }
  else
  {
    reverseA(pwr);
  }
}

/*前进*/
void forwardA(int pwm)
{
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, HIGH);
  analogWrite(PWMA_LEFT, pwm);
}

/*后退*/
 void reverseA(int pwm)
 {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  analogWrite(PWMA_LEFT, pwm);
} 

/*停车*/
void brakeA()
{
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, LOW);
}
/**********以上，声明电机，运动相关**********/


