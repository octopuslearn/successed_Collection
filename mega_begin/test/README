
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html




/*以下，一点一点移动*/
void armJoyCmd(char serialCmd)//Arduino根据手柄按键执行相应操作
{
   switch(serialCmd){
    case 'a':  // x_Base向左
      //Serial.println("x_Base向左");                
      baseJoyPos = myservo_x.read() - moveStep;
      servoCmd('x', baseJoyPos, DSD);
      break;  
      
    case 'b':  // x_Base向右
      //Serial.println("x_Base向右");                
      baseJoyPos = myservo_x.read() + moveStep;
      servoCmd('x', baseJoyPos, DSD);
      break;        
 
    case 's':  // y_rArm向下
    //Serial.println("y_rArm向下");                
      rArmJoyPos = myservo_y.read() + moveStep;
      servoCmd('y', rArmJoyPos, DSD);
      break;  
                 
    case 'w':  // y_rArm向上
      //Serial.println("y_rArm向上");     
      rArmJoyPos = myservo_y.read() - moveStep;
      servoCmd('y', rArmJoyPos, DSD);
      break;  
  }
  OLED_reportStatus();
} 
/*以上，一点一点移动*/



        int myservo_x_vlue=myservo_x.read();
        int myservo_y_vlue=myservo_y.read();
        int writeMic_myservo_x_vlue=map(myservo_x_vlue,0,180,500,2500);
        int writeMic_myservo_y_vlue=map(myservo_y_vlue,0,180,500,2500);
        u8g2.firstPage();
        do
        {
          u8g2.setFont(u8g_font_7x14); // 设置字体
          u8g2.drawStr(0, 10, "x: ");
          u8g2.setCursor(sizeof("x: ") * 6, 10);
          u8g2.print(myservo_x_vlue);
          u8g2.setCursor(sizeof("x: ") * 6+60, 10);
          u8g2.print(writeMic_myservo_x_vlue);

          u8g2.drawStr(0, 40, "y: ");
          u8g2.setCursor(sizeof("y: ") * 6, 40);
          u8g2.print(myservo_y_vlue);
          u8g2.setCursor(sizeof("y: ") * 6+60, 40);
          u8g2.print(writeMic_myservo_y_vlue);
        } while (u8g2.nextPage());







        /*以下，法1，一点一点移动*/
void armJoyCmd(char serialCmd)//Arduino根据手柄按键执行相应操作
{
   switch(serialCmd){
    case 'a':  // x_Base向左
      //Serial.println("x_Base向左");                
      baseJoyPos = myservo_x.read() - moveStep;
      servoCmd('x', baseJoyPos, DSD);
      break;  
      
    case 'b':  // x_Base向右
      //Serial.println("x_Base向右");                
      baseJoyPos = myservo_x.read() + moveStep;
      servoCmd('x', baseJoyPos, DSD);
      break;        
 
    case 's':  // y_rArm向下
    //Serial.println("y_rArm向下");                
      rArmJoyPos = myservo_y.read() + moveStep;
      servoCmd('y', rArmJoyPos, DSD);
      break;  
                 
    case 'w':  // y_rArm向上
      //Serial.println("y_rArm向上");     
      rArmJoyPos = myservo_y.read() - moveStep;
      servoCmd('y', rArmJoyPos, DSD);
      break;  
  }
  OLED_reportStatus();
} 
/*以下，法1，一点一点移动*/



/*以下，显示*/
        u8g2.firstPage();
        do
        {
          u8g2.setFont(u8g_font_7x14); // 设置字体
          u8g2.drawStr(0, 10, "contrl_reading");
          u8g2.drawStr(30,10, "contrl_reading");
          u8g2.setCursor(sizeof("cr_x: ") * 6, 10);
          u8g2.print(contrl_reading_baseJoyPos);
        } while (u8g2.nextPage());
/*以上，显示*/



        do
        {
          u8g2.setFont(u8g_font_7x14); // 设置字体
          u8g2.drawStr(0, 10, "@@wMc_REST@@");
          
          u8g2.drawStr(0, 25, "REST_x: ");
          u8g2.setCursor(sizeof("REST_x: ") * 6, 25);
          u8g2.print(myservo_xvlue);
          u8g2.setCursor(sizeof("REST_x: ") * 6+40, 25);
          u8g2.print(myservo_x_vlue);

          u8g2.drawStr(0, 40, "REST_y: ");
          u8g2.setCursor(sizeof("REST_x: ") * 6, 40);
          u8g2.print(myservo_yvlue);
          u8g2.setCursor(sizeof("REST_y: ") * 6+40, 40);
          u8g2.print(myservo_y_vlue);
        } while (u8g2.nextPage());



/*以下，显示*/
        u8g2.firstPage();
        do
        {
          u8g2.setFont(u8g_font_7x14); // 设置字体
          u8g2.drawStr(0, 10, "contrl_reading");
          u8g2.drawStr(0,25, "cr_x");
          u8g2.setCursor(sizeof("cr_x: ") * 6, 25);
          u8g2.print(contrl_reading_baseJoyPos);
        } while (u8g2.nextPage());
/*以上，显示*/


        u8g2.firstPage();
        do
        {
          u8g2.setFont(u8g_font_7x14); // 设置字体
          u8g2.drawStr(0, 10, "contrl_reading");
          u8g2.drawStr(0,25, "cr_x");
          u8g2.setCursor(sizeof("cr_x: ") * 6, 25);
          u8g2.print(contrl_reading_baseJoyPos);
        } while (u8g2.nextPage());



                u8g2.firstPage();
        do
        {
          u8g2.setFont(u8g_font_7x14); // 设置字体
          u8g2.drawStr(0, 10, "x: ");
          u8g2.setCursor(sizeof("x: ") * 8, 10);
          u8g2.print(myservo_x_vlue);
          u8g2.drawStr(0, 40, "y: ");
          u8g2.setCursor(sizeof("y: ") * 8, 40);
          u8g2.print(myservo_y_vlue);
        } while (u8g2.nextPage());








lr_data=data[2]/2/1.6*6.4;
fb_data=data[3]/2/1.7*6.4;
x_data_r=1512-lr_data;  x_data_l=1512+lr_data;
x_data_f=1378-fb_data;  x_data_b=1378+fb_data;
Serial.print("dlr_data: ");Serial.print(lr_data);//x
Serial.print("fb_data: ");Serial.print(fb_data);//y
Serial.print("x_data_r: ");Serial.print(x_data_r);Serial.print("x_data_l: ");Serial.print(x_data_l);
Serial.print("x_data_f: ");Serial.print(x_data_f);Serial.print("x_data_b: ");Serial.println(x_data_b);












#include <Arduino.h>
#include <SoftwareSerial.h>
SoftwareSerial mySerial(2, 3); // RX, TX




/**************以下，函数声明******************/
void sending_data(unsigned int First_data, unsigned int Second_data, unsigned int Third_data,unsigned int Four_data); //发送四个数据函数
void ReceiveDate(uint8_t num); //接收函数,每次调用只接收四个数据包里准确的数据刷新进全局data数组，接收正确就消亡了，要再接收必须重新调用。
/**************以上，函数声明******************/

unsigned int data[4];


void setup() {
  Serial.begin(115200); // 初始化串口通信，波特率为9600
  mySerial.begin(115200);    // 初始化虚拟串口
}

void loop() {
//  while(Serial.available()>0) char wrongCommand = Serial.read();  //清除串口缓存的错误指令
    sending_data(4,5,6,7);
    ReceiveDate(4);            //规定只接收四个数据
    Serial.println(data[2]);   //打印第三个数据 
  // for (int i = 0; i <3; i++) {
  //   Serial.print(data[i]); // 以十六进制格式输出数据包内容
  // }

}


void ReceiveDate(uint8_t num){
    uint8_t Flag =1;
    unsigned int RxState = 0;
    unsigned int RxCounter1 = 0;
    while (Flag)
    {
      while(Serial.available() > 0) {   
          uint16_t com_data = Serial.read();
          if (RxState == 0)
              {
                  if (com_data == 0xFF)
                  {
                      RxState = 1;
                      RxCounter1 = 0;
                      
                  }
              }
          else if (RxState == 1)
          {
              data[RxCounter1] = com_data;
              RxCounter1++;
              
              if (RxCounter1 >= num) //数据校验数据有多少就写多少
              {
                  RxState = 2;
              }
          }
          else if (RxState == 2)
          {
              if (com_data == 0xFE)
              {
                  RxState = 0;
                  Flag = 0;
              }
          }
      }

  }
  
}


void sending_data(unsigned int First_data, unsigned int Second_data, unsigned int Third_data,unsigned int Four_data) {
    unsigned char data[] = {0xFF, First_data,Second_data,Third_data,Four_data,0xFE};
    for (int i = 0; i < sizeof(data); i++) {
        mySerial.write(data[i]);
    }
}

